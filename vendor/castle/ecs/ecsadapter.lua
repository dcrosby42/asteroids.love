--
-- ECS module adapter
--
-- A function that adapts an "ECS Module" into a "castle Module"
--

-- (ecshelpers injects a bunch of commonly useful component/entity funcs globally)
require 'castle.ecs.ecshelpers'
local Editor = require('castle.ecs.editorgui')
local JoystickAdapter = require('castle.ecs.joystickadapter')
local G = love.graphics
local soundmanager = require('castle.soundmanager')

-- Implements
local function newWorld(ecsArgs)
  local res = ecsArgs.loadResources()
  local estore = ecsArgs.create(res)
  if not estore then
    local name = ecsArgs.name or "UNNAMED ECS MODULE"
    print(require("inspect")(ecsArgs))
    error("ecsArgs.create() for '" .. name .. "' must return an Estore!")
  end
  local world = {
    estore = estore,
    input = { dt = 0, events = {} },
    resources = res,

    editor = Editor.init(),
  }
  return world
end

local function doTick(ecsMod, world, action)
  -- Update the ECS world
  world.input.dt = action.dt
  ecsMod.update(world.estore, world.input, world.resources)
  local sidefx = world.input.events -- return events as potential sidefx
  -- reset input
  world.input.dt = 0
  world.input.events = {}

  if world.editor.recording then
    local copy = world.estore:clone({ keepCaches = true })
    world.editor.history:push(copy)
    world.editor.historyIndex = world.editor.history:length()
  end

  return world, sidefx
end

local function updateWorld(ecsMod, world, action)
  local sidefx
  local editing = world.editor.on
  local paused = world.editor.ui.pausedCheckbox.checked

  if action.state == 'pressed' and action.key == 'r' and action.gui then
    -- Reload game
    sidefx = { { type = "castle.reloadRootModule" } }
  elseif action.state == 'pressed' and action.key == 'escape' then
    -- toggle editor
    world.editor.on = not world.editor.on
    if world.editor.on then world.editor.ui.pausedCheckbox.checked = true end
  elseif action.type == "tick" then
    -- time passed? doTick
    if not paused then world, sidefx = doTick(ecsMod, world, action) end
    if editing then
      world.editor.estore = world.estore
      Editor.update(world.editor)
    end
  elseif action.type == 'keyboard' then
    if action.state == "pressed" then Editor.keypressed(action.key) end
    if not editing then
      table.insert(world.input.events, shallowclone(action))
    end
  elseif action.type == 'textinput' then
    Editor.textinput(action.text)
  elseif action.type == 'mouse' and not action.isTouch then
    -- convert mouse events to touch events (on desktop)
    -- (NB: action.isTouch indicates this mouse event was generated by a
    -- touchscreen.... which usually happens IN DUPLICATE with an ACTUAL touch
    -- event... in which case we suppress.)
    if not editing then
      local evt = shallowclone(action)
      evt.type = "touch"
      evt.id = "mousetouch1"
      table.insert(world.input.events, evt)
    end

    -- pass touch and keyboard events through:
  elseif action.type == 'touch' then
    if not editing then
      table.insert(world.input.events, shallowclone(action))
    end
  elseif action.type == 'joystick' then
    if not editing then
      JoystickAdapter.appendControllerEvents(world.input.events, action,
        "joystick1")
    end
  end

  return world, sidefx
end

local function drawEditor(ecsMod, world)
  local w = G.getWidth()
  local h = G.getHeight()
  Editor.draw(world.editor, { rect = { 0, 0, w, h } })
end

local function drawWorld(ecsMod, world)
  local paused = world.editor.ui.pausedCheckbox.checked
  if paused and world.editor.historyIndex > 0 then
    ecsMod.draw(Editor.getEstore(world.editor), world.resources)
  else
    ecsMod.draw(world.estore, world.resources)
  end

  if world.editor.on then
    drawEditor(ecsMod, world)
  end


  if paused then
    soundmanager.pause()
  else
    soundmanager.unpause()
  end
end

--
-- ecsMod is an "ECS Module" which is a Table with three keys to functions:
--   loadResources() -> resources
--   create(resources) -> estore
--   update(estore, action, resources) -> estore,sidefx
--   draw(estore,resources) -> nil
--
return function(ecsArgs)
  return {
    newWorld = function()
      return newWorld(ecsArgs)
    end,
    updateWorld = function(world, action)
      return updateWorld(ecsArgs, world, action)
    end,
    drawWorld = function(world)
      return drawWorld(ecsArgs, world)
    end,
  }
end
